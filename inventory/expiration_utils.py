"""
Utility functions for expiration tracking and waste management.
"""

from django.utils import timezone
from django.db.models import Q, Count, Sum, Avg
from datetime import date, timedelta
from decimal import Decimal
from typing import List, Dict, Optional

from .models import InventoryItem
from .expiration_models import ExpirationAlert, WasteLog, UserNotificationPreferences, ExpirationRule


def generate_expiration_alerts(user, days_ahead: int = 7) -> Dict[str, int]:
    """
    Generate expiration alerts for a user's inventory.
    
    Args:
        user: User to generate alerts for
        days_ahead: How many days to look ahead for expiring items
    
    Returns:
        Dictionary with count of alerts generated by type
    """
    preferences = UserNotificationPreferences.get_or_create_for_user(user)
    
    if not preferences.enable_expiration_alerts:
        return {'total': 0}
    
    # Get user's active inventory items with expiration dates
    inventory_items = InventoryItem.objects.filter(
        user=user,
        is_consumed=False,
        quantity__gt=0,
        expiration_date__isnull=False
    )
    
    today = timezone.now().date()
    alert_counts = {
        'expired': 0,
        'expiring_soon': 0,
        'use_first': 0,
        'opened_item': 0,
        'total': 0
    }
    
    for item in inventory_items:
        # Skip if alert already exists for this item today
        existing_alert = ExpirationAlert.objects.filter(
            user=user,
            inventory_item=item,
            alert_date=today,
            is_dismissed=False
        ).exists()
        
        if existing_alert:
            continue
        
        days_until_exp = item.days_until_expiration
        if days_until_exp is None:
            continue
        
        # Determine alert type and priority
        alert_type = None
        priority = 'medium'
        message = ""
        suggested_action = ""
        
        # Check for expired items
        if days_until_exp < 0:
            alert_type = 'expired'
            priority = 'urgent'
            days_past = abs(days_until_exp)
            message = f"{item.product.name} expired {days_past} day(s) ago"
            suggested_action = "Dispose of item or check if still safe to consume"
            
        # Check for items expiring soon
        elif days_until_exp <= preferences.urgent_alert_days:
            alert_type = 'expiring_soon'
            priority = 'urgent' if days_until_exp == 0 else 'high'
            if days_until_exp == 0:
                message = f"{item.product.name} expires today"
                suggested_action = "Use immediately or freeze if possible"
            else:
                message = f"{item.product.name} expires in {days_until_exp} day(s)"
                suggested_action = "Plan to use soon or consider freezing"
                
        elif days_until_exp <= preferences.alert_days_before_expiration:
            alert_type = 'expiring_soon'
            priority = 'medium'
            message = f"{item.product.name} expires in {days_until_exp} day(s)"
            suggested_action = "Plan to use in upcoming meals"
        
        # Check for opened items (if opened date exists and more than threshold)
        if (item.opened_date and 
            (today - item.opened_date).days >= _get_opened_shelf_life(item)):
            alert_type = 'opened_item'
            priority = 'high'
            days_opened = (today - item.opened_date).days
            message = f"{item.product.name} has been open for {days_opened} day(s)"
            suggested_action = "Check quality and use soon"
        
        # Create alert if needed
        if alert_type and _should_create_alert_type(preferences, alert_type):
            ExpirationAlert.objects.create(
                user=user,
                inventory_item=item,
                alert_type=alert_type,
                priority=priority,
                alert_date=today,
                days_until_expiration=days_until_exp,
                message=message,
                suggested_action=suggested_action
            )
            
            alert_counts[alert_type] += 1
            alert_counts['total'] += 1
    
    # Generate "use first" alerts for items expiring earliest
    _generate_use_first_alerts(user, preferences, alert_counts)
    
    return alert_counts


def _should_create_alert_type(preferences, alert_type: str) -> bool:
    """Check if user wants alerts for this type."""
    alert_settings = {
        'expired': preferences.alert_expired,
        'expiring_soon': preferences.alert_expiring_soon,
        'opened_item': preferences.alert_opened_items,
        'use_first': preferences.alert_use_first,
    }
    return alert_settings.get(alert_type, True)


def _generate_use_first_alerts(user, preferences, alert_counts: Dict):
    """Generate use-first alerts for items that should be prioritized."""
    if not preferences.alert_use_first:
        return
    
    # Get items expiring within the next week
    week_from_now = timezone.now().date() + timedelta(days=7)
    
    items_by_category = InventoryItem.objects.filter(
        user=user,
        is_consumed=False,
        quantity__gt=0,
        expiration_date__isnull=False,
        expiration_date__lte=week_from_now
    ).select_related('product__category').order_by('expiration_date')
    
    # Group by category
    categories = {}
    for item in items_by_category:
        category = item.product.category.name if item.product.category else 'Other'
        if category not in categories:
            categories[category] = []
        categories[category].append(item)
    
    # Create use-first alerts for earliest expiring item in each category
    for category, items in categories.items():
        if items:
            earliest_item = items[0]
            
            # Check if use-first alert already exists
            existing_alert = ExpirationAlert.objects.filter(
                user=user,
                inventory_item=earliest_item,
                alert_type='use_first',
                alert_date=timezone.now().date(),
                is_dismissed=False
            ).exists()
            
            if not existing_alert:
                ExpirationAlert.objects.create(
                    user=user,
                    inventory_item=earliest_item,
                    alert_type='use_first',
                    priority='medium',
                    alert_date=timezone.now().date(),
                    days_until_expiration=earliest_item.days_until_expiration,
                    message=f"Use {earliest_item.product.name} first in {category} category",
                    suggested_action=f"Prioritize this item when cooking"
                )
                
                alert_counts['use_first'] += 1
                alert_counts['total'] += 1


def _get_opened_shelf_life(item) -> int:
    """Get shelf life for opened items."""
    # Check for custom rules
    rules = ExpirationRule.objects.filter(
        user=item.user,
        is_active=True
    ).filter(
        Q(product=item.product) | Q(category=item.product.category)
    ).order_by('product', 'category')  # Product rules take precedence
    
    for rule in rules:
        if rule.opened_shelf_life_days:
            return rule.opened_shelf_life_days
    
    # Default opened shelf life by category
    category_shelf_life = {
        'dairy': 7,      # Milk, yogurt - 1 week after opening
        'condiments': 90, # Sauces, dressings - 3 months
        'beverages': 3,   # Juices - 3 days
        'produce': 3,     # Cut fruits/vegetables - 3 days
        'meat': 3,        # Opened packages - 3 days
        'pantry': 30,     # Opened dry goods - 1 month
    }
    
    if item.product.category:
        category_name = item.product.category.name.lower()
        return category_shelf_life.get(category_name, 7)  # Default 1 week
    
    return 7  # Default 1 week


def log_waste(user, inventory_item, waste_reason: str, quantity_wasted: Decimal, 
              notes: str = "", could_have_been_prevented: bool = True) -> WasteLog:
    """
    Log food waste for tracking and analysis.
    
    Args:
        user: User logging the waste
        inventory_item: InventoryItem that was wasted (can be None)
        waste_reason: Reason for waste
        quantity_wasted: Amount wasted
        notes: Additional notes
        could_have_been_prevented: Whether waste was preventable
    
    Returns:
        Created WasteLog instance
    """
    # Get product info
    if inventory_item:
        product_name = inventory_item.product.name
        category_name = inventory_item.product.category.name if inventory_item.product.category else ""
        purchase_date = inventory_item.purchase_date
        expiration_date = inventory_item.expiration_date
        unit = inventory_item.unit
        estimated_value = inventory_item.price
    else:
        # Manual entry
        product_name = "Unknown item"
        category_name = ""
        purchase_date = None
        expiration_date = None
        unit = "count"
        estimated_value = None
    
    # Calculate estimated value if not provided
    if not estimated_value and inventory_item:
        if inventory_item.price and inventory_item.quantity > 0:
            # Proportional value based on wasted quantity
            estimated_value = (inventory_item.price * quantity_wasted) / inventory_item.quantity
    
    waste_log = WasteLog.objects.create(
        user=user,
        inventory_item=inventory_item,
        product_name=product_name,
        category_name=category_name,
        waste_reason=waste_reason,
        quantity_wasted=quantity_wasted,
        unit=unit,
        estimated_value=estimated_value,
        purchase_date=purchase_date,
        expiration_date=expiration_date,
        could_have_been_prevented=could_have_been_prevented,
        notes=notes
    )
    
    # Update inventory item if provided
    if inventory_item:
        # Reduce quantity or mark as consumed
        if inventory_item.quantity <= quantity_wasted:
            inventory_item.quantity = 0
            inventory_item.is_consumed = True
            inventory_item.consumed_date = timezone.now()
        else:
            inventory_item.quantity -= quantity_wasted
        inventory_item.save()
    
    return waste_log


def get_expiration_dashboard_data(user) -> Dict:
    """
    Get comprehensive expiration dashboard data for a user.
    
    Args:
        user: User to get data for
    
    Returns:
        Dictionary with dashboard data
    """
    today = timezone.now().date()
    
    # Get active alerts
    active_alerts = ExpirationAlert.objects.filter(
        user=user,
        is_dismissed=False
    ).select_related('inventory_item__product')
    
    # Group alerts by type and priority
    alerts_by_type = {}
    alerts_by_priority = {}
    
    for alert in active_alerts:
        # By type
        if alert.alert_type not in alerts_by_type:
            alerts_by_type[alert.alert_type] = []
        alerts_by_type[alert.alert_type].append(alert)
        
        # By priority
        if alert.priority not in alerts_by_priority:
            alerts_by_priority[alert.priority] = []
        alerts_by_priority[alert.priority].append(alert)
    
    # Get inventory statistics
    inventory_items = InventoryItem.objects.filter(
        user=user,
        is_consumed=False,
        quantity__gt=0
    )
    
    total_items = inventory_items.count()
    items_with_expiration = inventory_items.filter(expiration_date__isnull=False).count()
    expired_items = inventory_items.filter(expiration_date__lt=today).count()
    expiring_soon = inventory_items.filter(
        expiration_date__gte=today,
        expiration_date__lte=today + timedelta(days=3)
    ).count()
    
    # Recent waste statistics (last 30 days)
    thirty_days_ago = today - timedelta(days=30)
    recent_waste = WasteLog.objects.filter(
        user=user,
        waste_date__gte=thirty_days_ago
    )
    
    waste_stats = {
        'total_items_wasted': recent_waste.count(),
        'total_value_wasted': recent_waste.aggregate(
            total=Sum('estimated_value')
        )['total'] or Decimal('0'),
        'preventable_waste': recent_waste.filter(could_have_been_prevented=True).count(),
    }
    
    # Waste by reason
    waste_by_reason = recent_waste.values('waste_reason').annotate(
        count=Count('id'),
        total_value=Sum('estimated_value')
    ).order_by('-count')
    
    return {
        'alerts': {
            'total_active': active_alerts.count(),
            'by_type': alerts_by_type,
            'by_priority': alerts_by_priority,
            'urgent_count': len(alerts_by_priority.get('urgent', [])),
            'high_count': len(alerts_by_priority.get('high', [])),
        },
        'inventory': {
            'total_items': total_items,
            'items_with_expiration': items_with_expiration,
            'expired_items': expired_items,
            'expiring_soon': expiring_soon,
            'tracking_percentage': (items_with_expiration / total_items * 100) if total_items > 0 else 0,
        },
        'waste': waste_stats,
        'waste_by_reason': list(waste_by_reason),
        'items_expiring_this_week': _get_items_expiring_this_week(user),
    }


def _get_items_expiring_this_week(user) -> List[Dict]:
    """Get items expiring within the next 7 days."""
    today = timezone.now().date()
    week_from_now = today + timedelta(days=7)
    
    items = InventoryItem.objects.filter(
        user=user,
        is_consumed=False,
        quantity__gt=0,
        expiration_date__gte=today,
        expiration_date__lte=week_from_now
    ).select_related('product', 'location').order_by('expiration_date')
    
    expiring_items = []
    for item in items:
        expiring_items.append({
            'id': item.id,
            'product_name': item.product.name,
            'quantity': float(item.quantity),
            'unit': item.get_unit_display(),
            'expiration_date': item.expiration_date,
            'days_until_expiration': item.days_until_expiration,
            'location': item.location.name if item.location else None,
            'category': item.product.category.name if item.product.category else None,
        })
    
    return expiring_items


def get_waste_analytics(user, days: int = 30) -> Dict:
    """
    Get waste analytics for a user over a specified period.
    
    Args:
        user: User to analyze
        days: Number of days to look back
    
    Returns:
        Dictionary with waste analytics
    """
    cutoff_date = timezone.now().date() - timedelta(days=days)
    
    waste_logs = WasteLog.objects.filter(
        user=user,
        waste_date__gte=cutoff_date
    )
    
    total_waste = waste_logs.count()
    total_value = waste_logs.aggregate(Sum('estimated_value'))['estimated_value__sum'] or Decimal('0')
    preventable_waste = waste_logs.filter(could_have_been_prevented=True).count()
    
    # Waste by category
    waste_by_category = waste_logs.values('category_name').annotate(
        count=Count('id'),
        total_value=Sum('estimated_value')
    ).order_by('-count')
    
    # Waste by reason
    waste_by_reason = waste_logs.values('waste_reason').annotate(
        count=Count('id'),
        total_value=Sum('estimated_value')
    ).order_by('-count')
    
    # Waste trends (by week)
    waste_trends = []
    for week in range(4):  # Last 4 weeks
        week_start = timezone.now().date() - timedelta(weeks=week+1)
        week_end = timezone.now().date() - timedelta(weeks=week)
        
        week_waste = waste_logs.filter(
            waste_date__gte=week_start,
            waste_date__lt=week_end
        )
        
        waste_trends.append({
            'week': week + 1,
            'start_date': week_start,
            'end_date': week_end,
            'total_items': week_waste.count(),
            'total_value': week_waste.aggregate(Sum('estimated_value'))['estimated_value__sum'] or Decimal('0'),
        })
    
    return {
        'period_days': days,
        'total_waste_items': total_waste,
        'total_waste_value': float(total_value),
        'preventable_waste_count': preventable_waste,
        'preventable_percentage': (preventable_waste / total_waste * 100) if total_waste > 0 else 0,
        'waste_by_category': list(waste_by_category),
        'waste_by_reason': list(waste_by_reason),
        'weekly_trends': waste_trends,
        'average_waste_per_week': total_waste / 4 if total_waste > 0 else 0,
        'estimated_annual_waste_value': float(total_value) * (365 / days) if total_value > 0 else 0,
    }


def bulk_update_expiration_dates(user, updates: List[Dict]) -> Dict[str, int]:
    """
    Bulk update expiration dates for multiple inventory items.
    
    Args:
        user: User updating items
        updates: List of dicts with 'item_id' and 'expiration_date'
    
    Returns:
        Dictionary with update statistics
    """
    stats = {
        'updated': 0,
        'errors': 0,
        'not_found': 0
    }
    
    for update in updates:
        try:
            item_id = update.get('item_id')
            expiration_date = update.get('expiration_date')
            
            if not item_id or not expiration_date:
                stats['errors'] += 1
                continue
            
            try:
                item = InventoryItem.objects.get(id=item_id, user=user)
                item.expiration_date = expiration_date
                item.save(update_fields=['expiration_date'])
                stats['updated'] += 1
            except InventoryItem.DoesNotExist:
                stats['not_found'] += 1
                
        except Exception:
            stats['errors'] += 1
    
    return stats